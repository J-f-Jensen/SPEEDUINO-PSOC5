#include <Wire.h>
#include "displayspecial.h"

//Required to load the class
OLED displayspecial(0x3c,2);

//==========================================================//

// Used to speed up things - Sending new big digits to the OLED is a slow process due to I2C speed
// limited to 100khz due to 14point7 WBO2 and the limits seen in the SH1106 controller in my display
// don't know if a display with SPI would be better
char lastChars0[6];
char lastChars1[6];
int lastValue0 = 254;
int lastValue1 = 254;


// Font created using the great CFE font tool that I found at this link - you have to take the data from the source files created, but it helps a lot
// https://forum.crystalfontz.com/showthread.php/6637-Text-graphic-C-code-for-CFAF320240?p=28164#post28164

// Big numbers font
const byte bigNumbers [] PROGMEM = {
    16, 32, // size of zero indicates fixed width font, actual length is width * height
    16,     // width - 16
    32,     // height - 32
    40,     // first char - 43
    18,     // char count - 15

    //char width table used due to that DOT is only 8 bytes width
    16, 16, 16, 16, 16, 16, 8, 16,      // char 40 - 47
    16, 16, 16, 16, 16, 16, 16, 16,     // char 48 - 55
    16, 16,                             // char 56 - 57

    // font data
    0x00, 0x0E, 0x00, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00,    // col 1 - 3 - 40
    0x1C, 0x01, 0x00, 0x00, 0x1C, 0x01, 0x00, 0x00, 0xF0, 0xE1, 0x7F, 0x00,    // col 4 - 6
    0xC0, 0xEF, 0x7F, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x20, 0x02, 0x00,    // col 7 - 9
    0x00, 0x20, 0xC0, 0xFF, 0x00, 0x20, 0xC0, 0xFF, 0x00, 0x00, 0x40, 0x1C,    // col 10 - 12
    0x00, 0x00, 0x40, 0x34, 0x00, 0x00, 0xC0, 0x67, 0x00, 0x00, 0x80, 0xC3,    // col 13 - 15
    0x00, 0x00, 0x00, 0x80,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x06, 0x00, 0xFC, 0x00, 0x09, 0x00,    // col 1 - 3
    0xF0, 0x07, 0x09, 0x00, 0x80, 0x1F, 0x06, 0x00, 0x00, 0x7C, 0xF0, 0x0F,    // col 4 - 6
    0x80, 0x1F, 0xFC, 0x3F, 0xF0, 0x07, 0x06, 0x60, 0xFC, 0x00, 0x03, 0xC0,    // col 7 - 9
    0xF0, 0x07, 0x03, 0xC0, 0x80, 0x1F, 0x03, 0xC0, 0x00, 0x7C, 0x06, 0x60,    // col 10 - 12
    0x80, 0x1F, 0x3C, 0x3C, 0xF0, 0x07, 0x38, 0x1C, 0xFC, 0x00, 0x00, 0x00,    // col 13 - 15
    0x1C, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 1 - 3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 4 - 6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 7 - 9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 10 - 12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 13 - 15
    0x00, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 1 - 3
    0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00,    // col 4 - 6
    0x00, 0x80, 0x07, 0x00, 0x00, 0xF8, 0x7F, 0x00, 0x00, 0xF8, 0x7F, 0x00,    // col 7 - 9
    0x00, 0xF8, 0x7F, 0x00, 0x00, 0xF8, 0x7F, 0x00, 0x00, 0x80, 0x07, 0x00,    // col 10 - 12
    0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00,    // col 13 - 15
    0x00, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 1 - 3 - 44
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x70,    // col 4 - 6
    0x00, 0x00, 0xF0, 0x3C, 0x00, 0x00, 0xF8, 0x3F, 0x00, 0x00, 0xF8, 0x1F,    // col 7 - 9
    0x00, 0x00, 0xF8, 0x07, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x00,    // col 10 - 12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 13 - 15
    0x00, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 1 - 3
    0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00,    // col 4 - 6
    0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00,    // col 7 - 9
    0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00,    // col 10 - 12
    0x00, 0x80, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 13 - 15
    0x00, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,    // col 1 - 3
    0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xFC,    // col 4 - 6
    0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x78,                            // col 7 - 8

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 1 - 3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 4 - 6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // col 7 - 9
    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00,    // col 10 - 12
    0xCC, 0x00, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00,    // col 13 - 15
    0x78, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0x0F,    // col 1 - 3 - 48 = 0
    0xF8, 0xFF, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F,    // col 4 - 6
    0x0E, 0x00, 0x00, 0xE0, 0x06, 0x00, 0x00, 0xC0, 0x06, 0x00, 0x00, 0xC0,    // col 7 - 9
    0x06, 0x00, 0x00, 0xC0, 0x06, 0x00, 0x00, 0xC0, 0x0E, 0x00, 0x00, 0xE0,    // col 10 - 12
    0xFC, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0x3F,    // col 13 - 15
    0xE0, 0xFF, 0xFF, 0x0F,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            // 49 = 1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x00,    // col
    0xE0, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF,    // col
    0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,    // col
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                             // col

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0xC0, 0xFF,    // col 1 - 3 - 50
    0xF8, 0x03, 0xE0, 0xFF, 0xFC, 0x03, 0xF0, 0xFF, 0xFC, 0x03, 0xF8, 0xFF,    // col 4 - 6
    0x0E, 0x00, 0x3C, 0xE0, 0x06, 0x00, 0x1E, 0xE0, 0x06, 0x00, 0x0F, 0xE0,    // col 7 - 9
    0x06, 0x80, 0x07, 0xE0, 0x06, 0xC0, 0x03, 0xE0, 0x0E, 0xE0, 0x01, 0xE0,    // col 10 - 12
    0xFC, 0xFF, 0x00, 0xE0, 0xFC, 0x7F, 0x00, 0xE0, 0xF8, 0x3F, 0x00, 0xE0,    // col 13 - 15
    0xE0, 0x0F, 0x00, 0xE0,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x01, 0x80, 0x0F,    // col 1 - 3
    0xF8, 0x01, 0x80, 0x3F, 0xFC, 0x01, 0x80, 0x7F, 0xFC, 0x01, 0x80, 0x7F,    // col 4 - 6
    0x0E, 0x00, 0x00, 0xE0, 0x06, 0x00, 0x00, 0xC0, 0x06, 0x00, 0x00, 0xC0,    // col 7 - 9
    0x06, 0xC0, 0x01, 0xC0, 0x06, 0xC0, 0x01, 0xC0, 0x0E, 0xE0, 0x03, 0xE0,    // col 10 - 12
    0xFC, 0xFF, 0xFF, 0x7F, 0xFC, 0x7F, 0xFF, 0x7F, 0xF8, 0x3F, 0xFE, 0x3F,    // col 13 - 15
    0xE0, 0x0F, 0xF8, 0x0F,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,    // col 1 - 3
    0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x3F, 0x03,    // col 4 - 6
    0x00, 0xE0, 0x07, 0x03, 0x00, 0xFC, 0x00, 0x03, 0x80, 0x1F, 0x00, 0x03,    // col 7 - 9
    0xF0, 0x01, 0x00, 0x03, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,    // col 10 - 12
    0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x03,    // col 13 - 15
    0x00, 0x00, 0x00, 0x03,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x81, 0x0F,    // col 1 - 3 - 53
    0xFC, 0xFF, 0x81, 0x3F, 0xFC, 0xFF, 0x81, 0x7F, 0xFC, 0xFF, 0x81, 0x7F,    // col 4 - 6
    0x0C, 0x30, 0x00, 0xE0, 0x0C, 0x18, 0x00, 0xC0, 0x0C, 0x18, 0x00, 0xC0,    // col 7 - 9
    0x0C, 0x18, 0x00, 0xC0, 0x0C, 0x18, 0x00, 0xC0, 0x0C, 0x38, 0x00, 0xE0,    // col 10 - 12
    0x0C, 0xF0, 0xFF, 0x7F, 0x0C, 0xF0, 0xFF, 0x7F, 0x0C, 0xE0, 0xFF, 0x3F,    // col 13 - 15
    0x00, 0x80, 0xFF, 0x0F,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0x0F,    // col 1 - 3
    0xF8, 0xFF, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F,    // col 4 - 6
    0x0E, 0xC0, 0x00, 0xE0, 0x06, 0x60, 0x00, 0xC0, 0x06, 0x60, 0x00, 0xC0,    // col 7 - 9
    0x06, 0x60, 0x00, 0xC0, 0x06, 0x60, 0x00, 0xC0, 0x0E, 0xC0, 0x00, 0xE0,    // col 10 - 12
    0xFC, 0xC3, 0xFF, 0x7F, 0xFC, 0xC3, 0xFF, 0x7F, 0xF8, 0x83, 0xFF, 0x3F,    // col 13 - 15
    0xE0, 0x03, 0xFE, 0x0F,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,    // col 1 - 3
    0x1C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0xF0, 0x1C, 0x00, 0x00, 0xFE,    // col 4 - 6
    0x1C, 0x00, 0xC0, 0xFF, 0x1C, 0x00, 0xF8, 0xFF, 0x1C, 0x00, 0xFF, 0x07,    // col 7 - 9
    0x1C, 0xE0, 0x7F, 0x00, 0x1C, 0xFC, 0x0F, 0x00, 0x9C, 0xFF, 0x01, 0x00,    // col 10 - 12
    0xFC, 0x3F, 0x00, 0x00, 0xFC, 0x07, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00,    // col 13 - 15
    0x1C, 0x00, 0x00, 0x00,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x07, 0xFE, 0x0F,    // col 1 - 3
    0xF8, 0x9F, 0xFF, 0x3F, 0xFC, 0x9F, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F,    // col 4 - 6
    0x0E, 0xF0, 0x00, 0xE0, 0x06, 0x60, 0x00, 0xC0, 0x06, 0x60, 0x00, 0xC0,    // col 7 - 9
    0x06, 0x60, 0x00, 0xC0, 0x06, 0x60, 0x00, 0xC0, 0x0E, 0xF0, 0x00, 0xE0,    // col 10 - 12
    0xFC, 0xFF, 0xFF, 0x7F, 0xFC, 0x9F, 0xFF, 0x7F, 0xF8, 0x9F, 0xFF, 0x3F,    // col 13 - 15
    0xE0, 0x07, 0xFE, 0x0F,                                                    // col 16

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0x80, 0x0F,    // col 1 - 3
    0xF8, 0xFF, 0x83, 0x3F, 0xFC, 0xFF, 0x87, 0x7F, 0xFC, 0xFF, 0x87, 0x7F,    // col 4 - 6
    0x0E, 0x00, 0x0E, 0xE0, 0x06, 0x00, 0x0C, 0xC0, 0x06, 0x00, 0x0C, 0xC0,    // col 7 - 9
    0x06, 0x00, 0x0C, 0xC0, 0x06, 0x00, 0x0C, 0xC0, 0x0E, 0x00, 0x06, 0xE0,    // col 10 - 12
    0xFC, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0x3F,    // col 13 - 15
    0xE0, 0xFF, 0xFF, 0x0F                                                     // col 16
};

// Small 8x8 font
static const char myFont[][8] PROGMEM = {
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x5F,0x00,0x00,0x00,0x00,0x00},
{0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x00},
{0x00,0x14,0x7F,0x14,0x7F,0x14,0x00,0x00},
{0x00,0x24,0x2A,0x7F,0x2A,0x12,0x00,0x00},
{0x00,0x23,0x13,0x08,0x64,0x62,0x00,0x00},
{0x00,0x36,0x49,0x55,0x22,0x50,0x00,0x00},
{0x00,0x00,0x05,0x03,0x00,0x00,0x00,0x00},
{0x00,0x1C,0x22,0x41,0x00,0x00,0x00,0x00},
{0x00,0x41,0x22,0x1C,0x00,0x00,0x00,0x00},
{0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00},
{0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00},
{0x00,0xA0,0x60,0x00,0x00,0x00,0x00,0x00},
{0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00},
{0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
{0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00},
{0x00,0x3E,0x51,0x49,0x45,0x3E,0x00,0x00},
{0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x00},
{0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x00},
{0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00},
{0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x00},
{0x00,0x27,0x45,0x45,0x45,0x39,0x00,0x00},
{0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x00},
{0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x00},
{0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00},
{0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00},
{0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00},
{0x00,0x00,0xAC,0x6C,0x00,0x00,0x00,0x00},
{0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x00},
{0x00,0x14,0x14,0x14,0x14,0x14,0x00,0x00},
{0x00,0x41,0x22,0x14,0x08,0x00,0x00,0x00},
{0x00,0x02,0x01,0x51,0x09,0x06,0x00,0x00},
{0x00,0x32,0x49,0x79,0x41,0x3E,0x00,0x00},
{0x00,0x7E,0x09,0x09,0x09,0x7E,0x00,0x00},
{0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x00},
{0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x00},
{0x00,0x7F,0x41,0x41,0x22,0x1C,0x00,0x00},
{0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x00},
{0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x00},
{0x00,0x3E,0x41,0x41,0x51,0x72,0x00,0x00},
{0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00},
{0x00,0x41,0x7F,0x41,0x00,0x00,0x00,0x00},
{0x00,0x20,0x40,0x41,0x3F,0x01,0x00,0x00},
{0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x00},
{0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x00},
{0x00,0x7F,0x02,0x0C,0x02,0x7F,0x00,0x00},
{0x00,0x7F,0x04,0x08,0x10,0x7F,0x00,0x00},
{0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x00},
{0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x00},
{0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x00},
{0x00,0x7F,0x09,0x19,0x29,0x46,0x00,0x00},
{0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00},
{0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x00},
{0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x00},
{0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x00},
{0x00,0x3F,0x40,0x38,0x40,0x3F,0x00,0x00},
{0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x00},
{0x00,0x03,0x04,0x78,0x04,0x03,0x00,0x00},
{0x00,0x61,0x51,0x49,0x45,0x43,0x00,0x00},
{0x00,0x7F,0x41,0x41,0x00,0x00,0x00,0x00},
{0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00},
{0x00,0x41,0x41,0x7F,0x00,0x00,0x00,0x00},
{0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x00},
{0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00},
{0x00,0x01,0x02,0x04,0x00,0x00,0x00,0x00},
{0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x00},
{0x00,0x7F,0x48,0x44,0x44,0x38,0x00,0x00},
{0x00,0x38,0x44,0x44,0x28,0x00,0x00,0x00},
{0x00,0x38,0x44,0x44,0x48,0x7F,0x00,0x00},
{0x00,0x38,0x54,0x54,0x54,0x18,0x00,0x00},
{0x00,0x08,0x7E,0x09,0x02,0x00,0x00,0x00},
{0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x00,0x00},
{0x00,0x7F,0x08,0x04,0x04,0x78,0x00,0x00},
{0x00,0x00,0x7D,0x00,0x00,0x00,0x00,0x00},
{0x00,0x80,0x84,0x7D,0x00,0x00,0x00,0x00},
{0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00},
{0x00,0x41,0x7F,0x40,0x00,0x00,0x00,0x00},
{0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x00},
{0x00,0x7C,0x08,0x04,0x7C,0x00,0x00,0x00},
{0x00,0x38,0x44,0x44,0x38,0x00,0x00,0x00},
{0x00,0xFC,0x24,0x24,0x18,0x00,0x00,0x00},
{0x00,0x18,0x24,0x24,0xFC,0x00,0x00,0x00},
{0x00,0x00,0x7C,0x08,0x04,0x00,0x00,0x00},
{0x00,0x48,0x54,0x54,0x24,0x00,0x00,0x00},
{0x00,0x04,0x7F,0x44,0x00,0x00,0x00,0x00},
{0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00},
{0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x00},
{0x00,0x3C,0x40,0x30,0x40,0x3C,0x00,0x00},
{0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00},
{0x00,0x1C,0xA0,0xA0,0x7C,0x00,0x00,0x00},
{0x00,0x44,0x64,0x54,0x4C,0x44,0x00,0x00},
{0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x00},
{0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},
{0x00,0x41,0x36,0x08,0x00,0x00,0x00,0x00},
{0x00,0x02,0x01,0x01,0x02,0x01,0x00,0x00},
{0x00,0x02,0x05,0x05,0x02,0x00,0x00,0x00}
};


//==========================================================//
// Resets display depending on the actual mode.
void OLED::reset_display(void)
{
  displayOff();
  clear_display();
  displayOn();
}

//==========================================================//
// Turns display on.
void OLED::displayOn(void)
{
  sendcommand(0xaf);        //display on
}

//==========================================================//
// Turns display off.
void OLED::displayOff(void)
{
  sendcommand(0xae);		//display off
}

//==========================================================//
// Clears the display by sendind 0 to all the screen map.
void OLED::clear_display(void)
{
  unsigned int i,k;
  for(k=0;k<8;k++)
  {
    setXY(0,k);

	  for(i=0;i<(128 + 2 * _offset);i++) //locate all COL
	  {
		    SendChar(0); //clear all COL
	  }
  }
}

// Special function - can handle input between -999.9 to 999.9
// Will always output in the x.x format
// input should be the number * 10
void OLED::PrintNumberSpecial(int n, uint8_t lineNr) {
   char chars[6];
   unsigned int fullNumber;
   unsigned int remNumber;
   uint8_t negativStatus = 0;
   uint8_t y = 0;

   // Check if a valid line number is recived and if data have changed since list time,
   if (lineNr == 0)
   {
     if (n == lastValue0) { return; }
     lastValue0 = n;
   }
   else if (lineNr == 1)
   {
     if (n == lastValue1) { return; }
     lastValue1 = n;
     y = 4;
   }
   else
   {
     // Not a valid line number - lets exit
     return;
   }

   // If zero, the just send the value and exit
   if ( n == 0 )
   {
      printBigNumber( "**0.0", 6 , y );
      return;
   }

   // Handle negative values, the range is limited to -99.0 - if you live in a clima colder than this it will fail
   if(n < 0)
   {
      n = -n;
      negativStatus = 1;
   }

   if ( y == 0 ) // Only AFR have a remainder and is *10
   {
     fullNumber = n / 10;
     remNumber = n % 10; // remainder
   }
   else // Water temp
   {
     fullNumber = n;
     remNumber = 0;
   }

   // I had some issues using a loop with fullNumber /= 10; - this works
   if ( fullNumber >= 100 )
   {
     chars[2] = (0x30 + fullNumber % 10);
     fullNumber /= 10;
     chars[1] = (0x30 + fullNumber % 10);
     fullNumber /= 10;
     chars[0] = (0x30 + fullNumber);
   }
   else if ( fullNumber >= 10 )
   {
     if ( negativStatus == 1 )
     {
       chars[0] = 45; // Minus sign
     }
     else
     {
       chars[0] = 42; // Blank
     }
     chars[2] = (0x30 + fullNumber % 10);
     fullNumber /= 10;
     chars[1] = (0x30 + fullNumber);
   }
   else
   {
     chars[0] = 42; // Blank
     if ( negativStatus == 1 )
     {
       chars[1] = 45; // Minus sign
     }
     else
     {
       chars[1] = 42; // Blank
     }
     chars[2] = (0x30 + fullNumber);
   }

   // Add dot
   chars[3] = 46;

   //Add a one digit reminder - we always round down!
   if ( remNumber == 0 )
   {
       chars[4] = 48;
   }
   else
   {
      //Get first digit if we have more than one - not needed in the current implementation but could be usefull later on
      // while( remNumber > 9 )
      // {
      //   remNumber /= 10;
      // }

      chars[4] = (0x30 + remNumber);
   }

   // zero = end of array
   chars[5] = 0;

   //Final we can send it to the display
   printBigNumber( chars, 6, y );
}

void OLED::printBigNumber(char *n, uint8_t x, uint8_t y ) {
	uint8_t width = 0;
	uint8_t height = pgm_read_byte(bigNumbers+FONT_HEIGHT);
  uint8_t bytes = (height+7)/8;
  uint8_t page = 0;
  uint16_t index = 0;
  char c;
  char *lastCharArray;
  uint8_t lastCharArrayIndex = 0;


  if (y==0)
  {
    lastCharArray = lastChars0;
  }
  else
  {
    lastCharArray = lastChars1;
  }


	uint8_t firstChar = pgm_read_byte(bigNumbers+FONT_FIRST_CHAR);
	uint8_t charCount = pgm_read_byte(bigNumbers+FONT_CHAR_COUNT);

  // SH1106 are handling blocks/pages of 8*8
  uint8_t heightIdent = height / 8;
  if ( (height % 8) > 0 ) { heightIdent++; }

  setXY(x, y);

  while(*n)
  {
    c = *n;

    page = 0;
    index = 0;

  	if(c < firstChar || c >= (firstChar+charCount)) {
  		c = 48;
  	}
  	c-= firstChar;

  	if( pgm_read_byte(bigNumbers+FONT_LENGTH) == 0 && pgm_read_byte(bigNumbers+FONT_LENGTH+1) == 0) {
      // zero length is flag indicating fixed width font (array does not contain width data entries)
  	   width = pgm_read_byte(bigNumbers+FONT_FIXED_WIDTH);
  	   index = c*bytes*width+FONT_WIDTH_TABLE;
  	}
  	else {
  	   // variable width font, read width data, to get the index
  	   for(uint8_t i=0; i<c; i++) {
  		 index += pgm_read_byte(bigNumbers+FONT_WIDTH_TABLE+i);
  	   }
  	   index = index*bytes+charCount+FONT_WIDTH_TABLE;
  	   width = pgm_read_byte(bigNumbers+FONT_WIDTH_TABLE+c);
    }

    // Check if the digit have changed, if not then we don't use time sendig it to the display
    if (lastCharArray[lastCharArrayIndex] != c)
    {
    	// last but not least, draw the character
    	for(uint8_t i=0; i<heightIdent; i++) {

        Wire.beginTransmission(_address); // begin transmitting
        Wire.write(0x40);//data mode

        for(uint8_t j=0; j < width; j++) {
          Wire.write(pgm_read_byte(bigNumbers+index+page+(j*heightIdent)));
    		}
        Wire.endTransmission();    // stop transmitting

        page++;
        setXY(x, ++y);
    	}

      y -= page;

      // Update the array
      lastCharArray[lastCharArrayIndex] = c;
    }

    lastCharArrayIndex++;

    x += width/8;
    if ( (width % 8) > 0 ) { x++; }

    setXY( x , y );
    *n++;
  }
}

//==========================================================//
// Actually this sends a byte, not a char to draw in the display.
// Display's chars uses 8 byte font the small ones and 96 bytes
// for the big number font.
void OLED::SendChar(unsigned char data)
{
  Wire.beginTransmission(_address); // begin transmitting
  Wire.write(0x40);//data mode
  Wire.write(data);
  Wire.endTransmission();    // stop transmitting
}

//==========================================================//
// Prints a display char (not just a byte) in coordinates X Y,
// being multiples of 8. This means we have 16 COLS (0-15)
// and 8 ROWS (0-7).
void OLED::sendCharXY(unsigned char data, int X, int Y)
{
  setXY(X, Y);
  Wire.beginTransmission(_address); // begin transmitting
  Wire.write(0x40);//data mode

  for(int i=0;i<8;i++)
    Wire.write(pgm_read_byte(myFont[data-0x20]+i));

  Wire.endTransmission();    // stop transmitting
}

//==========================================================//
// Used to send commands to the display.
void OLED::sendcommand(unsigned char com)
{
  Wire.beginTransmission(_address);     //begin transmitting
  Wire.write(0x80);                          //command mode
  Wire.write(com);
  Wire.endTransmission();                    // stop transmitting
}

//==========================================================//
// Set the cursor position in a 16 COL * 8 ROW map.
void OLED::setXY(unsigned char col,unsigned char row)
{
  sendcommand(_offset+(8*col&0x0f));       //set low col address
  sendcommand(0x10+((8*col>>4)&0x0f));  //set high col address
  sendcommand(0xb0+row);                //set page address
}


//==========================================================//
// Prints a string regardless the cursor position.
void OLED::sendStr(unsigned char *string)
{
  unsigned char i=0;

  Wire.beginTransmission(_address); // begin transmitting
  Wire.write(0x40);//data mode

  while(*string)
  {
    for(i=0;i<8;i++)
    {
      Wire.write(pgm_read_byte(myFont[*string-0x20]+i));
    }
    *string++;
  }
  Wire.endTransmission();    // stop transmitting
}

//==========================================================//
// Prints a string in coordinates X Y, being multiples of 8.
// This means we have 16 COLS (0-15) and 8 ROWS (0-7).
void OLED::sendStrXY( const char *string, int X, int Y)
{
  setXY(X,Y);

  Wire.beginTransmission(_address); // begin transmitting
  Wire.write(0x40);//data mode

  unsigned char i=0;
  while(*string)
  {

  	for(i=0;i<8;i++)
    {
      Wire.write(pgm_read_byte(myFont[*string-0x20]+i));
    }
    *string++;
  }
  Wire.endTransmission();    // stop transmitting
}


//==========================================================//
// Inits oled and draws logo at startup
void OLED::init_OLED(void)
{
  sendcommand(0xae);		          //display off
  sendcommand(0xa6);              //Set Normal Display (default)
  // Adafruit Init sequence for 128x64 OLED module
  sendcommand(0xAE);            //DISPLAYOFF
  sendcommand(0xD5);            //SETDISPLAYCLOCKDIV
  sendcommand(0x80);            // the suggested ratio 0x80
  sendcommand(0xA8);            //SSD1306_SETMULTIPLEX
  sendcommand(0x3F);
  sendcommand(0xD3);            //SETDISPLAYOFFSET
  sendcommand(0x0);             //no offset
  sendcommand(0x40 | 0x0);      //SETSTARTLINE
  sendcommand(0x8D);            //CHARGEPUMP
  sendcommand(0x14);
  sendcommand(0x20);             //MEMORYMODE
  sendcommand(0x00);             //0x0 act like ks0108

  //sendcommand(0xA0 | 0x1);      //SEGREMAP   //Rotate screen 180 deg
  sendcommand(0xA0);

  //sendcommand(0xC8);            //COMSCANDEC  Rotate screen 180 Deg
  sendcommand(0xC0);

  sendcommand(0xDA);              //0xDA
  sendcommand(0x12);              //COMSCANDEC
  sendcommand(0x81);              //SETCONTRAS
  sendcommand(0xCF);              //
  sendcommand(0xd9);              //SETPRECHARGE
  sendcommand(0xF1);
  sendcommand(0xDB);              //SETVCOMDETECT
  sendcommand(0x40);
  sendcommand(0xA4);              //DISPLAYALLON_RESUME
  sendcommand(0xA6);              //NORMALDISPLAY

  //clear_display();
  sendcommand(0x2e);              // stop scroll
  //----------------------------REVERSE comments----------------------------//
  sendcommand(0xa0);		          //seg re-map 0->127(default)
  sendcommand(0xa1);		          //seg re-map 127->0
  sendcommand(0xc8);
  delay(10);
  //----------------------------REVERSE comments----------------------------//
  // sendcommand(0xa7);           //Set Inverse Display
  // sendcommand(0xae);		        //display off
  sendcommand(0x20);              //Set Memory Addressing Mode
  sendcommand(0x00);              //Set Memory Addressing Mode ab Horizontal addressing mode
  //  sendcommand(0x02);          // Set Memory Addressing Mode ab Page addressing mode(RESET)
}


//==========================================================//


OLED::OLED(uint8_t address, uint8_t offset) {
	_address = address;
	_offset = offset;
}

	void OLED::begin(void) {
	// set up i2c
	Wire.begin();
	init_OLED();
	reset_display();
	lastValue0 = 254;
	lastValue1 = 254;

	// hardcoded for AFR/Water
	print("AFR",0,0);
	print("WATER",0,4);
	print("TEMP",0,5);

	// Initial values until we have the first measurements
	PrintNumberSpecial(0,0);
	// Display locks if we print both without a delay :-( Must be due to a limit in the ammount of data it can handle in one go
	// The current implementation cost 64*4+32*1=288 bytes to initialize one line of the big numbers. After this only changed numbers will be send
	delay(30);
	PrintNumberSpecial(0,1);
}

void OLED::on(void) {
	displayOn();
}

void OLED::off(void) {
	displayOff();
}

void OLED::clear(void) {
	clear_display();
}

void OLED::print(char *s, uint8_t r, uint8_t c) {
	sendStrXY(s, r, c);
}
